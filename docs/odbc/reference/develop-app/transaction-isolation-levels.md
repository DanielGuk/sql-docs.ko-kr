---
title: 트랜잭션 격리 수준 | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- dirty reads [ODBC]
- isolation levels [ODBC]
- nonrepeatable reads [ODBC]
- read uncommitted [ODBC]
- read committed [ODBC]
- serializable reads [ODBC]
- phantoms [ODBC]
- transaction isolation [ODBC]
- repeatable reads [ODBC]
- transactions [ODBC], isolation
ms.assetid: 0d638d55-ffd0-48fb-834b-406f466214d4
caps.latest.revision: 6
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: On Demand
ms.openlocfilehash: 28e0bd9447d5975a34e963477eceb61f654d824d
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/16/2018
---
# <a name="transaction-isolation-levels"></a>트랜잭션 격리 수준
*트랜잭션 격리 수준* 는 트랜잭션 격리 성공 범위의 측정값입니다. 특히, 트랜잭션 격리 수준은 다음과 같은 현상이의 유무 의해 정의 됩니다.  
  
-   **더티 읽기** A *커밋되지 않은 읽기* 트랜잭션이 아직 커밋되지 않았습니다 데이터를 읽는 경우에 발생 합니다. 예를 들어 트랜잭션 1 업데이트를 행 가정 합니다. 트랜잭션 2 1 트랜잭션이 커밋되면 업데이트 전에 업데이트 된 행을 읽습니다. 트랜잭션 1이 변경 내용을 롤백합니다 트랜잭션 2 되지 있었을로 간주 되는 데이터 읽기 있어야 합니다.  
  
-   **반복 되지 않는 읽기** A *반복 하지 않는 읽기* 때 트랜잭션이 동일한 행을 두 번 읽는 될 때마다 서로 다른 데이터를 가져옵니다. 예를 들어 1 트랜잭션 읽기를 한 행 가정 합니다. 트랜잭션 2 업데이트 또는 해당 행을 삭제 하 고 커밋합니다 업데이트 또는 삭제 합니다. 트랜잭션 1에서는 행을 다시 읽습니다, 다른 행 값을 검색 하거나 해당 행이 삭제 검색 합니다.  
  
-   **팬텀** A *가상* 행 검색 조건과 일치 하는 처음에 표시 되지 않습니다. 예를 들어 트랜잭션 1 몇 가지 검색 기준을 만족 하는 행 집합을 읽습니다. 트랜잭션 2 트랜잭션 1에 대 한 검색 조건과 일치 하는 update 또는 insert) (통해 새 행을 생성 합니다. 트랜잭션 1에 행을 읽는 문을 reexecutes를 경우 서로 다른 행 집합을을 가져옵니다.  
  
 이러한 현상에이 부합 (SQL 92에 정의 된) 하는 대로 4 개의 트랜잭션 격리 수준으로 정의 됩니다. 다음 표에서 각 현상이 발생할 수 있는 "X"를 표시 합니다.  
  
|트랜잭션 격리 수준|커밋되지 않은 읽기|반복 되지 않는 읽기|팬텀|  
|---------------------------------|-----------------|-------------------------|--------------|  
|커밋되지 않은 읽기|X|X|X|  
|커밋된 읽기|--|X|X|  
|반복 읽기|--|--|X|  
|직렬화 가능|--|--|--|  
  
 다음 표에 간단한 방법으로 DBMS 트랜잭션 격리 수준을 구현할 수 있습니다.  
  
> [!IMPORTANT]  
>  동시성 향상을 위해 이러한 보다 더 복잡 한 스키마를 사용 하는 대부분 Dbms 합니다. 이 예는 설명 목적 으로만 제공 됩니다. 특히 ODBC 어떻게 특정 Dbms 규정 하지 않는 트랜잭션은를 서로 격리 합니다.  
  
|트랜잭션 격리|가능한 구현|  
|---------------------------|-----------------------------|  
|커밋되지 않은 읽기|트랜잭션이 서로 격리 됩니다. DBMS 다른 트랜잭션 격리 수준이 지 원하는 경우 이러한 수준을 구현를 사용 하 여 메커니즘을 무시 합니다. 다른 트랜잭션이, 부정적인 영향 하지 않는 일반적으로 읽기 전용으로 Read Uncommitted 수준에서 실행 하는 트랜잭션이 됩니다.|  
|커밋된 읽기|트랜잭션 쓰기 다른 트랜잭션에 의해 잠긴 행 잠금; 됩니다. 될 때까지 대기 이렇게 하면 모든 "더티" 데이터를 읽지 못하게 합니다.<br /><br /> 읽기 잠금 (만 행을 읽고) 하는 경우 또는 쓰기 (업데이트 하거나 행을 삭제 하기) 경우에 대 한 잠금 다른 트랜잭션이 업데이트 하거나 삭제 하지 못하도록 현재 행 트랜잭션 보류 합니다. 트랜잭션이 현재 행 밖으로 이동 하는 경우 읽기 잠금을 해제 합니다. 커밋 또는 롤백될 때까지 쓰기 잠금이 유지 합니다.|  
|반복 읽기|트랜잭션 쓰기 다른 트랜잭션에 의해 잠긴 행 잠금; 됩니다. 될 때까지 대기 이렇게 하면 모든 "더티" 데이터를 읽지 못하게 합니다.<br /><br /> 트랜잭션 응용 프로그램 및 쓰기 잠금을에 삽입, 업데이트 또는 삭제 하는 모든 행에 반환 하는 모든 행에서 읽기 잠금을 보유 합니다. 예를 들어, 트랜잭션 SQL 문을 포함 하는 경우 **선택 \* 에서 주문**, 응용 프로그램 반입 트랜잭션 읽기 잠금은 행입니다. 트랜잭션이 SQL 문을 포함 하는 경우 **삭제에서 주문 여기서 상태는 '종결' =**, 트랜잭션 쓰기 잠금을 행에 삭제 합니다.<br /><br /> 다른 트랜잭션이 업데이트 하거나 이러한 행을 삭제할 수 없습니다, 때문에 현재 트랜잭션이 모든 반복 되지 않는 읽기를 방지 합니다. 트랜잭션이 커밋되거나 롤백될 때 잠금을 해제 합니다.|  
|직렬화 가능|트랜잭션 쓰기 다른 트랜잭션에 의해 잠긴 행 잠금; 됩니다. 될 때까지 대기 이렇게 하면 모든 "더티" 데이터를 읽지 못하게 합니다.<br /><br /> 트랜잭션이 잠금을 보유 하 고 읽기 (만 행을 읽고) 하는 경우 쓰기 잠금을 (업데이트 하거나 행을 삭제할) 경우의 범위에 영향을 줌 것 행 또는 합니다. 예를 들어, 트랜잭션 SQL 문을 포함 하는 경우 **선택 \* 에서 주문**, 범위는 전체 Orders 테이블; 트랜잭션 읽기-잠금은 테이블과 않습니다 새 행을 삽입할 수 없도록 합니다. 트랜잭션이 SQL 문을 포함 하는 경우 **삭제에서 주문 여기서 상태는 '종결' =**, 트랜잭션 쓰기 잠금의 주문의 모든 행 테이블 "CLOSED" 및 상태와 함께 하지 않으면 범위는 "CLOSED"의 상태와 함께 모든 행 행을 삽입 하거나 결과 행에 "CLOSED"의 상태 업데이트를 허용 합니다.<br /><br /> 다른 트랜잭션이 업데이트 하거나 범위에서 행을 삭제할 수 없습니다, 때문에 현재 트랜잭션이 모든 반복 되지 않는 읽기를 방지 합니다. 다른 트랜잭션 범위에 모든 행을 삽입할 수 없습니다, 때문에 현재 트랜잭션이 모든 팬텀 방지할 수 있습니다. 트랜잭션이 커밋되거나 롤백될 때 잠금을 해제 합니다.|  
  
 트랜잭션 격리 수준을 자체 변경 사항을;을 확인 하는 트랜잭션 기능 영향을 주지 않습니다 해야 트랜잭션을 변경 항상 볼 수 있습니다. 예를 들어 트랜잭션이 포함 될 수 있습니다 두 **업데이트** 의 모든 직원의 급여가 10%를 발생 시키고 일부 최대 크기를 해당 값을 통해 모든 직원의 급여가 설정 하는 중 두 번째 문입니다. 이 작업은 성공 단일 트랜잭션으로 때문에 두 번째 **업데이트** 문을 첫 번째 결과 볼 수 있습니다.
